//! # D-Bus interface proxy for: `org.freedesktop.DBus.ObjectManager`
//!
//! This code was generated by `zbus-xmlgen` `4.1.0` from D-Bus introspection data.
//! Source: `Interface '/org/freedesktop/NetworkManager/Devices/2' from service 'org.freedesktop.DBus.ObjectManager' on system bus`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
//! following zbus API can be used:
//!
//! * [`zbus::fdo::PropertiesProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PeerProxy`]
//!
//! Consequently, `zbus-xmlgen` did not generate code for the above interfaces.
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,

//! The `proxy` module provides the [`DeviceProxy`] type, which implements the [`UpowerInterface`] trait
//! for interacting with Upower over D-Bus.
//!
//! See [`UpowerInterface`] for available methods.
use crate::interfaces::UPowerInterface;
use anyhow::Result;
use async_trait::async_trait;
use log::error;
use zbus::proxy::PropertyStream;
use zbus::{proxy, Connection};

/// Represents errors that can occur when interacting with D-Bus proxies.
#[derive(Debug, Clone, thiserror::Error)]
pub enum ProxyError {
    /// Indicates that a D-Bus method call failed.
    #[error("dbus call failed: {0}")]
    DbusCallFailed(String),
}

#[proxy(
    interface = "org.freedesktop.UPower.Device",
    default_service = "org.freedesktop.UPower",
    default_path = "/org/freedesktop/UPower/devices/DisplayDevice"
)]
pub trait Device {
    /// WarningLevel property
    #[zbus(property)]
    fn warning_level(&self) -> Result<u32>;

    /// Percentage property
    #[zbus(property)]
    fn percentage(&self) -> Result<f64>;

    /// BatteryLevel property
    #[zbus(property)]
    fn battery_level(&self) -> Result<u32>;

    /// State property
    #[zbus(property)]
    fn state(&self) -> Result<u32>;

    /// Type property
    #[zbus(property)]
    fn type_(&self) -> Result<u32>;
}

#[async_trait]
impl<'a> UPowerInterface for DeviceProxy<'a> {
    /// Asynchronously retrieves the battery level of the device.
    /// The level of the battery for devices which do not report a percentage but rather
    /// a coarse battery level. If the value is None, then the device does not support
    /// coarse battery reporting, and the percentage should be used instead.
    ///
    /// # Returns
    /// * `Ok(u32)` - The battery level as a percentage (0-100).
    /// * `Err(ProxyError::DbusCallFailed)` - If the battery level could not be retrieved.
    async fn get_battery_level(&self) -> Result<u32, ProxyError> {
        match self.battery_level().await {
            Ok(level) => Ok(level),
            Err(e) => {
                error!("failed to get battery level: {}", e);
                Err(ProxyError::DbusCallFailed(format!(
                    "failed to get battery level: {}",
                    e
                )))
            }
        }
    }

    /// Asynchronously retrieves the warning level of the device.
    ///
    /// # Returns
    /// * `Ok(u32)` - The warning level as a raw integer value.
    /// * `Err(ProxyError::DbusCallFailed)` - If the warning level could not be retrieved.
    async fn get_warning_level(&self) -> Result<u32, ProxyError> {
        match self.warning_level().await {
            Ok(level) => Ok(level),
            Err(e) => {
                error!("failed to get warning level: {}", e);
                Err(ProxyError::DbusCallFailed(format!(
                    "failed to get warning level: {}",
                    e
                )))
            }
        }
    }

    /// Asynchronously retrieves the battery percentage of the device.
    ///
    /// # Returns
    /// * `Ok(f64)` - The battery percentage (e.g., 75.0).
    /// * `Err(ProxyError::DbusCallFailed)` - If the percentage could not be retrieved.
    async fn get_percentage(&self) -> Result<f64, ProxyError> {
        match self.percentage().await {
            Ok(percentage) => Ok(percentage),
            Err(e) => {
                error!("failed to get battery percentage: {}", e);
                Err(ProxyError::DbusCallFailed(format!(
                    "failed to get battery percentage: {}",
                    e
                )))
            }
        }
    }

    /// Asynchronously retrieves the battery state of the device.
    ///
    /// # Returns
    /// * `Ok(u32)` - The battery state as a raw integer value.
    /// * `Err(ProxyError::DbusCallFailed)` - If the state could not be retrieved.
    async fn get_state(&self) -> Result<u32, ProxyError> {
        match self.state().await {
            Ok(state) => Ok(state),
            Err(e) => {
                error!("failed to get battery state: {}", e);
                Err(ProxyError::DbusCallFailed(format!(
                    "failed to get battery state: {}",
                    e
                )))
            }
        }
    }

    /// Asynchronously retrieves the type of power source.
    /// # Returns
    /// * `Ok(u32)` - The device types as a raw integer value.
    /// * `Err(ProxyError::DbusCallFailed)` - If the type could not be retrieved.
    async fn get_power_source_type(&self) -> Result<u32, ProxyError> {
        match self.type_().await {
            Ok(type_) => Ok(type_),
            Err(e) => {
                error!("failed to get power source type: {}", e);
                Err(ProxyError::DbusCallFailed(format!(
                    "failed to get power source type: {}",
                    e
                )))
            }
        }
    }

    /// Asynchronously retrieves a device state change event string.
    ///
    /// # Returns
    /// * `Ok(String)` - The event string (currently always empty).
    /// * `Err(ProxyError::Error)` - If the event string could not be retrieved.
    async fn stream_device_state(&self) -> Result<PropertyStream<u32>, ProxyError> {
        let cn = &self.0.connection();
        let device_proxy = get_device_proxy(cn).await?;
        let stream = device_proxy.receive_state_changed().await;
        Ok(stream)
    }
    async fn stream_device_percentage(&self) -> Result<PropertyStream<f64>, ProxyError> {
        let cn = &self.0.connection();
        let device_proxy = get_device_proxy(cn).await?;
        let stream = device_proxy.receive_percentage_changed().await;
        Ok(stream)
    }
    async fn stream_battery_level(&self) -> Result<PropertyStream<u32>, ProxyError> {
        let cn = &self.0.connection();
        let device_proxy = get_device_proxy(cn).await?;
        let stream = device_proxy.receive_battery_level_changed().await;
        Ok(stream)
    }
}

async fn get_device_proxy<'a>(cn: &'a Connection) -> Result<DeviceProxy<'a>, ProxyError> {
    let proxy = match DeviceProxy::new(&cn).await {
        Ok(n) => n,
        Err(e) => {
            error!("failed to create Device proxy: {}", e);
            return Err(ProxyError::DbusCallFailed(format!("{}", e)));
        }
    };
    Ok(proxy)
}