//! # D-Bus interface proxy for: `org.freedesktop.NetworkManager`
//!
//! This code was generated by `zbus-xmlgen` `4.1.0` from D-Bus introspection data.
//! Source: `Interface '/org/freedesktop/NetworkManager' from service 'org.freedesktop.NetworkManager' on system bus`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
//! following zbus API can be used:
//!
//! * [`zbus::fdo::PropertiesProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PeerProxy`]
//!
//! Consequently `zbus-xmlgen` did not generate code for the above interfaces.
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,

//! The `proxy` module provides the [`NetworkManagerProxy`] type, which implements the [`NetworkManagerInterface`] trait
//! for interacting with NetworkManager over D-Bus.
//!
//! See [`NetworkManagerInterface`] for available methods.
pub use crate::interfaces::NetworkManagerInterface;
pub mod access_point;
mod connection;
pub mod device;
mod settings;
pub mod wireless;

use std::collections::HashMap;

pub use anyhow::Result;
use async_trait::async_trait;
pub use device as device_proxy;
use log::{error, info, trace};
use uuid::Uuid;
use zbus::{
    proxy, zvariant::{ObjectPath, Value},
    Connection,
};

use super::interfaces::wireless::RawAccessPointInfo;
use crate::proxies::access_point::AccessPointProxy;
use crate::proxies::wireless::{AccessPointAddedStream, AccessPointRemovedStream, WirelessDeviceProxy};
use zbus::proxy::PropertyStream;
use zbus::zvariant::{OwnedObjectPath, Str};

// Define a constant for WiFi device type (as per NetworkManager specification)
const WIFI_DEVICE_TYPE: u32 = 2;
/// Represents errors that can occur when interacting with D-Bus proxies.
#[derive(Debug, Clone, thiserror::Error)]
pub enum ProxyError {
    /// Indicates that a D-Bus method call failed.
    #[error("dbus call failed: {0}")]
    DbusCallFailed(String),

    /// Indicates that an invalid device path was provided.
    #[error("invalid device path: {0}")]
    InvalidDevicePath(String),

    /// Indicates that a D-Bus proxy creation failed.
    #[error("failed to create proxy: {0}")]
    ProxyCreationFailed(String),

    /// Indicates that a no wifi device found.
    #[error("no wifi device found")]
    NoWifiDeviceFound,
}

#[proxy(
    interface = "org.freedesktop.NetworkManager",
    default_service = "org.freedesktop.NetworkManager",
    default_path = "/org/freedesktop/NetworkManager"
)]
pub trait NetworkManager {
    /// ActivateConnection method
    fn activate_connection(
        &self,
        connection: &zbus::zvariant::ObjectPath<'_>,
        device: &zbus::zvariant::ObjectPath<'_>,
        specific_object: &zbus::zvariant::ObjectPath<'_>,
    ) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// AddAndActivateConnection method
    fn add_and_activate_connection(
        &self,
        connection: std::collections::HashMap<
            &str,
            std::collections::HashMap<&str, &zbus::zvariant::Value<'_>>,
        >,
        device: &zbus::zvariant::ObjectPath<'_>,
        specific_object: &zbus::zvariant::ObjectPath<'_>,
    ) -> zbus::Result<(
        zbus::zvariant::OwnedObjectPath,
        zbus::zvariant::OwnedObjectPath,
    )>;

    /// AddAndActivateConnection2 method
    #[allow(clippy::too_many_arguments)]
    fn add_and_activate_connection2(
        &self,
        connection: std::collections::HashMap<
            &str,
            std::collections::HashMap<&str, &zbus::zvariant::Value<'_>>,
        >,
        device: &zbus::zvariant::ObjectPath<'_>,
        specific_object: &zbus::zvariant::ObjectPath<'_>,
        options: std::collections::HashMap<&str, &zbus::zvariant::Value<'_>>,
    ) -> zbus::Result<(
        zbus::zvariant::OwnedObjectPath,
        zbus::zvariant::OwnedObjectPath,
        std::collections::HashMap<String, zbus::zvariant::OwnedValue>,
    )>;

    /// CheckConnectivity method
    fn check_connectivity(&self) -> zbus::Result<u32>;

    /// CheckpointAdjustRollbackTimeout method
    fn checkpoint_adjust_rollback_timeout(
        &self,
        checkpoint: &zbus::zvariant::ObjectPath<'_>,
        add_timeout: u32,
    ) -> zbus::Result<()>;

    /// CheckpointCreate method
    fn checkpoint_create(
        &self,
        devices: &[&zbus::zvariant::ObjectPath<'_>],
        rollback_timeout: u32,
        flags: u32,
    ) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// CheckpointDestroy method
    fn checkpoint_destroy(&self, checkpoint: &zbus::zvariant::ObjectPath<'_>) -> zbus::Result<()>;

    /// CheckpointRollback method
    fn checkpoint_rollback(
        &self,
        checkpoint: &zbus::zvariant::ObjectPath<'_>,
    ) -> zbus::Result<std::collections::HashMap<String, u32>>;

    /// DeactivateConnection method
    fn deactivate_connection(
        &self,
        active_connection: &zbus::zvariant::ObjectPath<'_>,
    ) -> zbus::Result<()>;

    /// Enable method
    fn enable(&self, enable: bool) -> zbus::Result<()>;

    /// GetAllDevices method
    fn get_all_devices(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedObjectPath>>;

    /// GetDeviceByIpIface method
    fn get_device_by_ip_iface(&self, iface: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// GetDevices method
    fn get_devices(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedObjectPath>>;

    /// GetLogging method
    fn get_logging(&self) -> zbus::Result<(String, String)>;

    /// GetPermissions method
    fn get_permissions(&self) -> zbus::Result<std::collections::HashMap<String, String>>;

    /// Reload method
    fn reload(&self, flags: u32) -> zbus::Result<()>;

    /// SetLogging method
    fn set_logging(&self, level: &str, domains: &str) -> zbus::Result<()>;

    /// Sleep method
    fn sleep(&self, sleep: bool) -> zbus::Result<()>;

    /// state method
    // #[zbus(name = "state")]
    // fn state(&self) -> zbus::Result<u32>;

    /// CheckPermissions signal
    #[zbus(signal)]
    fn check_permissions(&self) -> zbus::Result<()>;

    /// DeviceAdded signal
    #[zbus(signal)]
    fn device_added(&self, device_path: zbus::zvariant::ObjectPath<'_>) -> zbus::Result<()>;

    /// DeviceRemoved signal
    #[zbus(signal)]
    fn device_removed(&self, device_path: zbus::zvariant::ObjectPath<'_>) -> zbus::Result<()>;

    /// StateChanged signal
    // #[zbus(signal)]
    // fn state_changed(&self, state: u32) -> zbus::Result<()>;

    /// ActivatingConnection property
    #[zbus(property)]
    fn activating_connection(&self) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// ActiveConnections property
    #[zbus(property)]
    fn active_connections(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedObjectPath>>;

    /// AllDevices property
    #[zbus(property)]
    fn all_devices(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedObjectPath>>;

    /// Capabilities property
    #[zbus(property)]
    fn capabilities(&self) -> zbus::Result<Vec<u32>>;

    /// Checkpoints property
    #[zbus(property)]
    fn checkpoints(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedObjectPath>>;

    /// Connectivity property
    #[zbus(property)]
    fn connectivity(&self) -> zbus::Result<u32>;

    /// ConnectivityCheckAvailable property
    #[zbus(property)]
    fn connectivity_check_available(&self) -> zbus::Result<bool>;

    /// ConnectivityCheckEnabled property
    #[zbus(property)]
    fn connectivity_check_enabled(&self) -> zbus::Result<bool>;
    #[zbus(property)]
    fn set_connectivity_check_enabled(&self, value: bool) -> zbus::Result<()>;

    /// ConnectivityCheckUri property
    #[zbus(property)]
    fn connectivity_check_uri(&self) -> zbus::Result<String>;

    /// Devices property
    #[zbus(property)]
    fn devices(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedObjectPath>>;

    /// GlobalDnsConfiguration property
    #[zbus(property)]
    fn global_dns_configuration(
        &self,
    ) -> zbus::Result<std::collections::HashMap<String, zbus::zvariant::OwnedValue>>;
    // #[zbus(property)]
    // fn set_global_dns_configuration(
    //     &self,
    //     value: std::collections::HashMap<&str, &zbus::zvariant::Value<'_>>,
    // ) -> zbus::Result<()>;

    /// Metered property
    #[zbus(property)]
    fn metered(&self) -> zbus::Result<u32>;

    /// NetworkingEnabled property
    #[zbus(property)]
    fn networking_enabled(&self) -> zbus::Result<bool>;

    /// PrimaryConnection property
    #[zbus(property)]
    fn primary_connection(&self) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// PrimaryConnectionType property
    #[zbus(property)]
    fn primary_connection_type(&self) -> zbus::Result<String>;

    /// RadioFlags property
    #[zbus(property)]
    fn radio_flags(&self) -> zbus::Result<u32>;

    /// Startup property
    #[zbus(property)]
    fn startup(&self) -> zbus::Result<bool>;

    /// State property
    #[zbus(property)]
    fn state(&self) -> zbus::Result<u32>;

    /// Version property
    #[zbus(property)]
    fn version(&self) -> zbus::Result<String>;

    /// VersionInfo property
    #[zbus(property)]
    fn version_info(&self) -> zbus::Result<Vec<u32>>;

    /// WimaxEnabled property
    #[zbus(property)]
    fn wimax_enabled(&self) -> zbus::Result<bool>;
    #[zbus(property)]
    fn set_wimax_enabled(&self, value: bool) -> zbus::Result<()>;

    /// WimaxHardwareEnabled property
    #[zbus(property)]
    fn wimax_hardware_enabled(&self) -> zbus::Result<bool>;

    /// WirelessEnabled property
    #[zbus(property)]
    fn wireless_enabled(&self) -> zbus::Result<bool>;
    #[zbus(property)]
    fn set_wireless_enabled(&self, value: bool) -> zbus::Result<()>;

    /// WirelessHardwareEnabled property
    #[zbus(property)]
    fn wireless_hardware_enabled(&self) -> zbus::Result<bool>;

    /// WwanEnabled property
    #[zbus(property)]
    fn wwan_enabled(&self) -> zbus::Result<bool>;
    #[zbus(property)]
    fn set_wwan_enabled(&self, value: bool) -> zbus::Result<()>;

    /// WwanHardwareEnabled property
    #[zbus(property)]
    fn wwan_hardware_enabled(&self) -> zbus::Result<bool>;
}

/// A utility macro to simplify handling asynchronous operations and error handling.
///
/// The `try_property!` macro is designed to work with asynchronous expressions that return
/// a `Result` type. It allows the caller to await the expression, handle the `Ok` variant,
/// and execute a custom error-handling function or operation for the `Err` variant.
///
/// # Syntax
/// ```ignore
/// try_property!($expression, $on_error);
/// ```
///
/// - `$expression`: An asynchronous expression that resolves to a `Result`.
/// - `$on_error`: A closure, function, or operation to be executed when the `$expression`
///   results in an `Err`.
///
macro_rules! try_property {
    ($expr:expr, $on_err:expr) => {
        match $expr.await {
            Ok(val) => val,
            Err(e) => $on_err(e),
        }
    };
}

// Implement the NetworkManagerInterface trait for NetworkManagerProxy
#[async_trait]
impl NetworkManagerInterface for NetworkManagerProxy<'_> {
    /// Toggle wireless via NetworkManager.
    async fn toggle_wireless(&self, enabled: bool) -> Result<(), ProxyError> {
        info!("toggle wireless: {}", enabled);
        // Call the underlying D-Bus method to set a wireless state.
        match self.set_wireless_enabled(enabled).await {
            Ok(_) => {
                info!("wifi is set to : {}", enabled);
                Ok(())
            }
            Err(e) => {
                error!("failed to set WiFi: {}", e);
                Err(ProxyError::DbusCallFailed(format!(
                    "failed to set WiFi: {}",
                    e
                )))
            }
        }
    }

    /// List all available Wireless networks by querying all devices, filtering for wireless networks, and collecting access point info.
    async fn list_networks(&self) -> Result<Vec<RawAccessPointInfo>, ProxyError> {
        info!("listing available WiFi networks...");
        // Fetch all network devices from NetworkManager.
        let devices = match self.get_all_devices().await {
            Ok(devices) => devices,
            Err(e) => {
                error!("failed to get devices: {}", e);
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to get devices: {}",
                    e
                )));
            }
        };
        trace!("found {} devices", devices.len());
        // Initialize a vector to hold the networks.
        let mut networks = Vec::new();

        let device = match get_wireless_device_path(&self.0.connection()).await {
            Ok(device) => device,
            Err(e) => {
                error!("failed to get device path: {}", e);
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to get device path: {}",
                    e
                )));
            }
        };
        // Create a proxy for the device.


        // Create a proxy for the wireless interface.
        let wireless_proxy =
            match WirelessDeviceProxy::new(&self.0.connection(), &device).await {
                Ok(proxy) => proxy,
                Err(e) => {
                    error!(
                                "failed to create wireless proxy for {}, error {}",
                                device,
                                e.to_string()
                            );
                    return Err(ProxyError::ProxyCreationFailed(format!(
                        "failed to create wireless proxy for {}, error {}",
                        device, e.to_string()
                    )));
                }
            };
        let active_access_point = match get_active_access_point(&self.0.connection(), &wireless_proxy).await {
            Ok(access_point) => access_point,
            Err(e) => {
                error!(
                            "failed to get active access point for {}, error {}",
                            device,
                            e.to_string()
                        );
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to get active access point for {}, error {}",
                    device, e.to_string()
                )));
            }
        };
        let active_ssid_vec = try_property!(active_access_point.ssid(), |e| {
                        error!("failed to get SSID for access point: {}", e);
                        Vec::new()
                    });
        // Get the list of all access points visible to this device, including hidden ones for which the SSID is not yet known.
        let access_points = match wireless_proxy.get_all_access_points().await {
            Ok(access_points) => access_points,
            Err(e) => {
                error!(
                            "failed to get access points for {}, error {}",
                            device,
                            e.to_string()
                        );
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to get access points for {}, error {}",
                    device, e.to_string()
                )));
            }
        };

        for access_point in access_points {
            // Create a proxy for the access point.
            let access_point_proxy = match access_point::AccessPointProxy::new(
                &self.0.connection(),
                access_point,
            )
                .await
            {
                Ok(proxy) => proxy,
                Err(_) => continue,
            };

            // Extract properties from the access point.
            let ssid_vec = try_property!(access_point_proxy.ssid(), |e| {
                        error!("failed to get SSID for access point: {}", e);
                        Vec::new()
                    });
            let flags = try_property!(access_point_proxy.flags(), |e| {
                        error!("failed to get flags for access point: {}", e);
                        0
                    });
            let frequency = try_property!(access_point_proxy.frequency(), |e| {
                        error!("failed to get frequency for access point: {}", e);
                        0
                    });
            let bandwidth = try_property!(access_point_proxy.bandwidth(), |e| {
                        error!("failed to get bandwidth for access point: {}", e);
                        0
                    });
            let signal_strength = try_property!(access_point_proxy.strength(), |e| {
                        error!("failed to get signal strength for access point: {}", e);
                        0
                    });
            let hw_address = try_property!(access_point_proxy.hw_address(), |e| {
                        error!("failed to get hardware address for access point: {}", e);
                        String::new()
                    });

            // Build the access point info struct.
            let raw_access_point_info = RawAccessPointInfo {
                ssid: String::from_utf8_lossy(&ssid_vec).to_string(),
                is_active: active_ssid_vec == ssid_vec,
                flags,
                frequency,
                bandwidth,
                strength: signal_strength,
                hw_address,
                ..Default::default()
            };
            networks.push(raw_access_point_info);
        }
        Ok(networks)
    }

    /// Attempt to connect to a WiFi network with the given SSID and optional password.
    async fn connect_to_network(
        &self,
        ssid: &str,
        password: &Option<String>,
    ) -> Result<(String, String), ProxyError> {
        info!("connecting to network: {}", ssid);
        let cn = self.0.connection();
        // Find the D-Bus object path for the WiFi device.
        let wifi_device_path = match get_wireless_device_path(&cn).await {
            Ok(path) => path,
            Err(e) => {
                error!("failed to get WiFi device path: {}", e);
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to get wireless device path: {}",
                    e
                )));
            }
        };

        // Use the root object for the specific object (typically "/").
        let specific_object = ObjectPath::try_from("/").unwrap();
        let mut connection = HashMap::new();

        // Build the "connection" settings.
        let mut connection_connection = HashMap::new();
        let binding = Value::from(&ssid);
        connection_connection.insert("id", &binding);
        let binding = Value::from("802-11-wireless");
        connection_connection.insert("type", &binding);
        let binding = Value::from(Uuid::new_v4().to_string());
        connection_connection.insert("uuid", &binding);
        connection.insert("connection", connection_connection);

        // Build the "802-11-wireless" settings.
        let mut connection_wireless = HashMap::new();
        let binding = Value::from(ssid.as_bytes().to_vec());
        connection_wireless.insert("ssid", &binding);
        let binding = Value::from("infrastructure");
        connection_wireless.insert("mode", &binding);
        connection.insert("802-11-wireless", connection_wireless);

        // Build the "802-11-wireless-security" settings if a password is provided.
        let mut connection_wireless_security = HashMap::new();
        let binding = Value::from("wpa-psk");
        connection_wireless_security.insert("key-mgmt", &binding);
        let binding = Value::from(password.clone().unwrap_or_default());
        connection_wireless_security.insert("psk", &binding);
        connection.insert("802-11-wireless-security", connection_wireless_security);

        // Set IPv4 to automatic configuration.
        let mut connection_ipv4 = HashMap::new();
        let binding = Value::from("auto");
        connection_ipv4.insert("method", &binding);
        connection.insert("ipv4", connection_ipv4);

        // Set IPv6 to ignore.
        let mut connection_ipv6 = HashMap::new();
        let binding = Value::from("ignore");
        connection_ipv6.insert("method", &binding);
        connection.insert("ipv6", connection_ipv6);

        // Add and activate the connection using the composed settings.
        match self
            .add_and_activate_connection(connection, &wifi_device_path, &specific_object)
            .await
        {
            Ok((new_connection_obj_path, active_connection_obj_path)) => Ok((
                new_connection_obj_path.to_string(),
                active_connection_obj_path.to_string(),
            )),
            Err(e) => {
                error!("failed to connect to network: {}", e);
                Err(ProxyError::DbusCallFailed(format!(
                    "failed to connect to network: {}",
                    e
                )))
            }
        }
    }

    /// Connects to a saved network using the given ssid.
    ///
    /// # Parameters
    ///
    /// * `ssid` - The ssid of the saved network.
    ///
    /// # Returns
    ///
    /// * `Ok(())` if the connection attempt is successful.
    /// * `Err` if any step fails, with context-specific error information.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The settings proxy could not be created.
    /// - The connection attempt fails.
    /// - The wireless device path could not be obtained.
    /// - The connection could not be activated.
    ///
    async fn connect_to_saved_network(&self, ssid: &str) -> Result<(), ProxyError> {
        info!("connecting saved network...");
        let cn = self.0.connection();
        let settings_proxy = match settings::SettingsProxy::new(&cn).await {
            Ok(proxy) => proxy,
            Err(e) => {
                error!("failed to create settings proxy: {}", e);
                return Err(ProxyError::ProxyCreationFailed(format!(
                    "failed to create settings proxy: {}",
                    e
                )));
            }
        };

        let nm_proxy = create_nm_proxy(&cn).await?;
        let connections = settings_proxy.list_connections().await.unwrap();
        for c in connections {
            let connection_proxy = connection::ConnectionProxy::new(&cn, c.clone())
                .await
                .unwrap();
            let settings = connection_proxy.get_settings().await.unwrap();
            let access_point = (*settings["connection"]["id"])
                .downcast_ref::<Str>()
                .unwrap()
                .to_string();
            let device_path = get_wireless_device_path(&cn).await?;
            let device = match ObjectPath::try_from(device_path) {
                Ok(path) => path,
                Err(e) => {
                    error!("failed to get wireless device path: {}", e);
                    return Err(ProxyError::InvalidDevicePath(format!(
                        "failed to get wireless device path: {}",
                        e
                    )));
                }
            };
            let specific_object = ObjectPath::try_from("/").unwrap();
            if access_point == ssid {
                let result = match nm_proxy
                    .activate_connection(&c, &device, &specific_object)
                    .await
                {
                    Ok(result) => result,
                    Err(e) => {
                        error!("failed to activate connection: {}", e);
                        return Err(ProxyError::DbusCallFailed(format!(
                            "failed to activate connection: {}",
                            e
                        )));
                    }
                };
                info!("activated connection: {}", result);
                break;
            }
        }
        Ok(())
    }

    /// Forgets a saved network.
    ///
    /// This function takes a SSID of a network to forget and deletes the corresponding connection
    /// from the network manager. If the network is currently connected, it disconnects the network
    /// first before forgetting it.
    ///
    /// # Errors
    ///
    /// * [`ProxyError::ProxyCreationFailed`] if creating a settings proxy fails.
    /// * [`ProxyError::DbusCallFailed`] if listing connections or getting connection settings fails.
    /// * [`ProxyError::InvalidDevicePath`] if getting the wireless device path fails.
    async fn forget_saved_network(&self, ssid: &str) -> Result<(), ProxyError> {
        info!("forgetting saved network...");
        let cn = self.0.connection();
        let settings_proxy = match settings::SettingsProxy::new(&cn).await {
            Ok(proxy) => proxy,
            Err(e) => {
                error!("failed to create settings proxy: {}", e);
                return Err(ProxyError::ProxyCreationFailed(format!(
                    "failed to create settings proxy: {}",
                    e
                )));
            }
        };
        let connections = match settings_proxy.list_connections().await {
            Ok(connections) => connections,
            Err(e) => {
                error!("failed to list connections: {}", e);
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to list connections: {}",
                    e
                )));
            }
        };
        for c in connections {
            let connection_proxy = match connection::ConnectionProxy::new(&cn, c.clone()).await {
                Ok(proxy) => proxy,
                Err(e) => {
                    error!("failed to create connection proxy: {}", e);
                    return Err(ProxyError::ProxyCreationFailed(format!(
                        "failed to create connection proxy: {}",
                        e
                    )));
                }
            };

            let settings = match connection_proxy.get_settings().await {
                Ok(settings) => settings,
                Err(e) => {
                    error!("failed to get connection settings: {}", e);
                    return Err(ProxyError::DbusCallFailed(format!(
                        "failed to get connection settings: {}",
                        e
                    )));
                }
            };
            let access_point = (*settings["connection"]["id"])
                .downcast_ref::<Str>()
                .unwrap()
                .to_string();

            if access_point == ssid {
                let _result = match connection_proxy.delete().await {
                    Ok(result) => result,
                    Err(e) => {
                        error!("failed to delete connection: {}", e);
                        return Err(ProxyError::DbusCallFailed(format!(
                            "failed to delete connection: {}",
                            e
                        )));
                    }
                };
                info!("deleted connection: {}", access_point);
                break;
            }
        }
        Ok(())
    }

    /// Disconnect from the current wireless network.
    ///
    /// Note: This disables the wireless connection, but credentials remain saved.
    async fn disconnect(&self) -> Result<(), ProxyError> {
        let cn = self.0.connection();
        // Get the wireless device path.
        let device_path = match get_wireless_device_path(cn).await {
            Ok(path) => path,
            Err(e) => {
                return Err(e.into());
            }
        };

        // Create a proxy for the device.
        let device_proxy = match device::DeviceProxy::new(&cn, device_path).await {
            Ok(proxy) => proxy,
            Err(e) => {
                error!("failed to create device proxy: {}", e);
                return Err(ProxyError::ProxyCreationFailed(format!(
                    "failed to create device proxy: {}",
                    e
                )));
            }
        };

        // Request disconnection.
        match device_proxy.disconnect().await {
            Ok(res) => Ok(res),
            Err(e) => {
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to disconnect: {}",
                    e
                )));
            }
        }
    }

    async fn get_access_point_info(
        &self,
        object_path: &str,
    ) -> Result<RawAccessPointInfo, ProxyError> {
        let cn = self.0.connection();
        // Create a proxy for the access point
        let access_point_proxy = match AccessPointProxy::new(cn, object_path).await {
            Ok(proxy) => proxy,
            Err(e) => {
                error!("failed to create access point proxy: {}", e);
                return Err(ProxyError::ProxyCreationFailed(format!(
                    "failed to create access point proxy: {}",
                    e
                )));
            }
        };
        // Get the access point properties
        // Extract properties from the access point.
        let ssid_vec = try_property!(access_point_proxy.ssid(), |e| {
            error!("failed to get SSID for access point: {}", e);
            Vec::new()
        });
        let flags = try_property!(access_point_proxy.flags(), |e| {
            error!("failed to get flags for access point: {}", e);
            0
        });
        let frequency = try_property!(access_point_proxy.frequency(), |e| {
            error!("failed to get frequency for access point: {}", e);
            0
        });
        let bandwidth = try_property!(access_point_proxy.bandwidth(), |e| {
            error!("failed to get bandwidth for access point: {}", e);
            0
        });
        let signal_strength = try_property!(access_point_proxy.strength(), |e| {
            error!("failed to get signal strength for access point: {}", e);
            0
        });
        let hw_address = try_property!(access_point_proxy.hw_address(), |e| {
            error!("failed to get hardware address for access point: {}", e);
            String::new()
        });

        // Build the access point info struct.
        Ok(RawAccessPointInfo {
            ssid: String::from_utf8_lossy(&ssid_vec).to_string(),
            flags,
            frequency,
            bandwidth,
            strength: signal_strength,
            hw_address,
            ..Default::default()
        })
    }
    /// Subscribe to NetworkManager WiFi state change events.
    async fn stream_device_events(&self) -> Result<PropertyStream<u32>, ProxyError> {
        let cn = self.0.connection();
        let proxy = create_nm_proxy(&cn).await?;
        let stream = proxy.receive_state_changed().await;
        Ok(stream)
    }

    async fn stream_access_point_events(
        &self,
    ) -> Result<(AccessPointAddedStream, AccessPointRemovedStream), ProxyError> {
        // Get the D-Bus connection from the proxy
        let cn = self.0.connection();
        // Get the path to the wireless device
        let device_path = match get_wireless_device_path(&cn).await {
            Ok(path) => path,
            Err(e) => {
                error!("failed to get WiFi device path: {}", e);
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to get wireless device path: {}",
                    e
                )));
            }
        };

        // Create a proxy for the wireless device interface
        let wireless_device_proxy =
            match wireless::WirelessDeviceProxy::new(&self.0.connection(), &device_path).await {
                Ok(proxy) => proxy,
                Err(e) => {
                    error!("failed to create wireless device proxy: {}", e);
                    return Err(ProxyError::ProxyCreationFailed(format!(
                        "failed to create wireless device proxy: {}",
                        e
                    )));
                }
            };

        // Set up stream subscriptions for both add and remove events
        let (add_result, remove_result) = futures::join!(
            wireless_device_proxy.receive_access_point_added(),
            wireless_device_proxy.receive_access_point_removed()
        );

        // Handle potential subscription errors
        let (access_point_added_stream, access_point_removed_stream) =
            match (add_result, remove_result) {
                (Ok(add_stream), Ok(remove_stream)) => (add_stream, remove_stream),
                (Err(e1), Err(e2)) => {
                    error!("Dual subscription failure: {e1}, {e2}");
                    return Err(ProxyError::DbusCallFailed(format!(
                        "failed to subscribe to both events: {e1} & {e2}"
                    )));
                }
                (Err(e), _) | (_, Err(e)) => {
                    error!("Partial subscription failure: {e}");
                    return Err(ProxyError::DbusCallFailed(format!(
                        "partial subscription failure: {e}"
                    )));
                }
            };
        Ok((access_point_added_stream, access_point_removed_stream))
    }
    async fn stream_wireless_enabled_status(&self) -> Result<PropertyStream<bool>, ProxyError> {
        let cn = self.0.connection();
        let proxy = create_nm_proxy(&cn).await?;
        let stream = proxy.receive_wireless_enabled_changed().await;
        Ok(stream)
    }
    async fn stream_wireless_network_strength(&self) -> Result<PropertyStream<u8>, ProxyError> {
        let cn = self.0.connection();
        let proxy = create_nm_proxy(&cn).await?;
        let device = match get_wireless_device_path(&self.0.connection()).await {
            Ok(device) => device,
            Err(e) => {
                error!("failed to get device path: {}", e);
                return Err(e);
            }
        };

        // Create a proxy for the wireless interface.
        let wireless_proxy =
            match WirelessDeviceProxy::new(&self.0.connection(), &device).await {
                Ok(proxy) => proxy,
                Err(e) => {
                    error!(
                                "failed to create wireless proxy for {}, error {}",
                                device,
                                e.to_string()
                            );
                    return Err(ProxyError::ProxyCreationFailed(format!(
                        "failed to create wireless proxy for {}, error {}",
                        device, e.to_string()
                    )));
                }
            };
        let active_access_point = match get_active_access_point(&cn, &wireless_proxy).await {
            Ok(access_point) => access_point,
            Err(e) => {
                error!("failed to get active access point: {}", e);
                return Err(e);
            }
        };
        let stream = active_access_point.receive_strength_changed().await;
        Ok(stream)
    }
}

async fn get_active_access_point<'a>(cn: &Connection, wireless_proxy: &wireless::WirelessDeviceProxy<'_>) -> Result<AccessPointProxy<'a>, ProxyError> {
    let active_access_point = match wireless_proxy.active_access_point().await {
        Ok(access_point) => access_point,
        Err(e) => {
            error!(
                            "failed to get active access point error {}",

                            e.to_string()
                        );
            return Err(ProxyError::DbusCallFailed(format!(
                "failed to get active access point error {}",
                e.to_string()
            )));
        }
    };
    let active_access_point = match AccessPointProxy::new(
        &cn,
        active_access_point,
    )
        .await
    {
        Ok(proxy) => proxy,
        Err(err) => {
            error!("failed to create access point proxy: {}", err);
            return Err(ProxyError::ProxyCreationFailed(format!(
                "failed to create access point proxy: {}",
                err
            )));
        }
    };
    Ok(active_access_point)
}

/// Creates a new NetworkManager proxy from the given D-Bus connection.
///
/// # Arguments
/// * `cn` - The D-Bus connection to use
///
/// # Returns
/// A NetworkManagerProxy or ProxyError if creation fails
async fn create_nm_proxy(cn: &Connection) -> Result<NetworkManagerProxy<'_>, ProxyError> {
    NetworkManagerProxy::new(cn).await.map_err(|e| {
        error!("failed to create NetworkManager proxy: {}", e);
        ProxyError::ProxyCreationFailed(format!("failed to create NetworkManager proxy: {}", e))
    })
}

/// Helper function to find the D-Bus object path of the first WiFi device.
///
/// Returns the object path as a String or an error if no WiFi device is found.
async fn get_wireless_device_path(cn: &Connection) -> Result<OwnedObjectPath, ProxyError> {
    info!("getting WiFi device path...");
    // Create a proxy to NetworkManager.
    let proxy = create_nm_proxy(cn).await?;
    // Get all devices.
    let devices = match proxy.get_all_devices().await {
        Ok(devices) => devices,
        Err(e) => {
            error!("failed to get devices: {}", e);
            return Err(ProxyError::DbusCallFailed(format!(
                "failed to get devices: {}",
                e
            )));
        }
    };
    trace!("found {} devices", devices.len());

    // Iterate and return the path of the first WiFi device (type == WIFI_DEVICE_TYPE).
    for device in devices {
        let device_proxy = match device::DeviceProxy::new(&cn, device.clone()).await {
            Ok(proxy) => proxy,
            Err(e) => {
                error!("failed to create device proxy: {}", e);
                continue;
            }
        };

        match device_proxy.device_type().await {
            Ok(device_type) => {
                if device_type == WIFI_DEVICE_TYPE {
                    info!("found WiFi device: {}", device);
                    return Ok(device);
                }
            }
            Err(e) => {
                error!("failed to get device type: {}", e);
                continue;
            }
        }
    }
    Err(ProxyError::NoWifiDeviceFound.into())
}
