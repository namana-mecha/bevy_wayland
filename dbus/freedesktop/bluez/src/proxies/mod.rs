//! # D-Bus interface proxy for: `org.freedesktop.DBus.ObjectManager`
//!
//! This code was generated by `zbus-xmlgen` `4.1.0` from D-Bus introspection data.
//! Source: `Interface '/org/freedesktop/NetworkManager/Devices/2' from service 'org.freedesktop.DBus.ObjectManager' on system bus`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
//! following zbus API can be used:
//!
//! * [`zbus::fdo::PropertiesProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PeerProxy`]
//!
//! Consequently `zbus-xmlgen` did not generate code for the above interfaces.
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,
// use std::collections::HashMap;
// use zbus::proxy;
// use zbus::zvariant::{OwnedObjectPath, Value};

// #[proxy(
//     interface = "org.freedesktop.DBus.ObjectManager",
//     default_service = "org.bluez"
// )]

// trait BluezProxy {
//     fn GetManagedObjects(
//         &self,
//     ) -> zbus::Result<HashMap<OwnedObjectPath, HashMap<String, HashMap<String, Value<'static>>>>>;
// }

//! The `proxy` module provides the [`BluezProxy`] type, which implements the [`BluezInterface`] trait
//! for interacting with BlueZ over D-Bus.
//!
//! See [`BluezInterface`] for available methods.

use super::interfaces::device::BluetoothDevice;
use adapter1::Adapter1Proxy;
use anyhow::{bail, Result};
use async_trait::async_trait;
use device::build_device_proxy;
use log::{debug, error, info, trace};

pub mod adapter1;
pub mod device;

use crate::interfaces::BluezInterface;
use crate::proxies::device::Device1Proxy;
use futures::StreamExt;
use std::collections::HashMap;
use zbus::fdo::ObjectManagerProxy;
use zbus::proxy;
use zbus::proxy::PropertyStream;
use zbus::zvariant::{ObjectPath, OwnedObjectPath, OwnedValue};

const DEVICE_OBJECT_PATH: &str = "/org/bluez/hci0/dev";

/// Represents errors that can occur when interacting with D-Bus proxies.
#[derive(Debug, Clone, thiserror::Error)]
#[non_exhaustive]
pub enum ProxyError {
    /// Indicates that a D-Bus method call failed.
    #[error("dbus call failed: {0}")]
    DbusCallFailed(String),

    /// Indicates failure to create an adapter proxy.
    #[error("failed to create adapter proxy: {0}")]
    AdapterProxyCreationFailed(String),

    /// Indicates to the caller that the device path is invalid.
    #[error("invalid object path: {0}")]
    InvalidObjectPath(String),

    /// Indicates that the device proxy build is getting failed.
    #[error("failed to build device proxy: {0}")]
    BuildDeviceProxyFailed(String),

    /// Indicates that the set device proxy path failed.
    #[error("failed to set device proxy path: {0}")]
    SetDeviceProxyPathFailed(String),
}

#[proxy(
    interface = "org.freedesktop.DBus.ObjectManager",
    default_service = "org.bluez",
    default_path = "/"
)]
pub trait Bluez {
    fn get_managed_objects(
        &self,
    ) -> zbus::Result<HashMap<OwnedObjectPath, HashMap<String, HashMap<String, OwnedValue>>>>;

    /// Emitted when an interface is added to an object.
    #[zbus(signal)]
    fn interfaces_added(
        &self,
        object: OwnedObjectPath,
        interfaces: HashMap<String, HashMap<String, OwnedValue>>,
    ) -> zbus::Result<()>;

    /// Emitted when an interface is removed from an object.
    #[zbus(signal)]
    fn interfaces_removed(
        &self,
        object: OwnedObjectPath,
        interfaces: Vec<String>,
    ) -> zbus::Result<()>;
}

#[async_trait]
impl<'a> BluezInterface for BluezProxy<'a> {
    /// Enables or disables Bluetooth on the adapter.
    ///
    /// # Arguments
    ///
    /// * `enabled` - Whether to enable or disable Bluetooth.
    ///
    /// # Returns
    ///
    /// * `Ok(())` if the Bluetooth powered state is successfully set.
    /// * `Err` if setting the Bluetooth powered state fails.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Creating the adapter proxy fails.
    /// - Setting the Bluetooth powered state fails.
    async fn toggle_bluetooth(&self, enabled: bool) -> Result<(), ProxyError> {
        info!("request to set bluetooth powered state to {}", enabled);

        let connection = self.0.connection();
        let adapter_proxy = match Adapter1Proxy::new(connection).await {
            Ok(proxy) => proxy,
            Err(e) => {
                error!("failed to create adapter proxy: {}", e);
                return Err(ProxyError::AdapterProxyCreationFailed(e.to_string()));
            }
        };

        match adapter_proxy.set_powered(enabled).await {
            Ok(_) => {
                info!("bluetooth powered state set to {}", enabled);
                Ok(())
            }
            Err(e) => {
                error!("failed to set bluetooth powered state : {}", e);
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to set bluetooth powered state: {}",
                    e
                )));
            }
        }
    }


    /// Discovers and returns a list of available Bluetooth devices.
    ///
    /// This asynchronous method performs Bluetooth device discovery by interacting with the BlueZ D-Bus API.
    /// It starts discovery, waits for a short period to allow devices to be found, stops discovery,
    /// then retrieves and filters the managed objects to return discovered Bluetooth devices.
    ///
    /// # Arguments
    /// * `discovery_duration` - The duration to scan for Bluetooth devices.
    ///
    /// # Returns
    ///
    /// * `Ok(Vec<BluetoothDevice>)` - A vector of discovered Bluetooth device properties on success.
    /// * `Err` - If any D-Bus or discovery operation fails.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The adapter proxy cannot be created.
    /// - Discovery cannot be started or stopped.
    /// - Managed objects cannot be retrieved.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let devices = my_struct.get_available_devices(discovery_duration).await?;
    /// for device in devices {
    ///     println!("{:?}", device);
    /// }
    /// ```
    async fn get_available_devices(
        &self,
        discovery_duration: core::time::Duration,
    ) -> Result<Vec<BluetoothDevice>, ProxyError> {
        info!("starting Bluetooth device discovery");
        let cn = &self.0.connection();
        let adapter_proxy = match Adapter1Proxy::new(cn).await {
            Ok(proxy) => proxy,
            Err(e) => {
                error!("failed to create adapter proxy: {}", e);
                return Err(ProxyError::AdapterProxyCreationFailed(e.to_string()));
            }
        };

        // Start the discovery process
        if let Err(e) = adapter_proxy.start_discovery().await {
            error!("failed to start bluetooth discovery: {}", e);
            return Err(ProxyError::DbusCallFailed(format!(
                "failed to start bluetooth discovery: {}",
                e
            )));
        }

        trace!("discovery started, waiting for devices...");
        tokio::time::sleep(discovery_duration).await;
        trace!("stopping discovery...");

        // Stop the discovery process
        if let Err(e) = adapter_proxy.stop_discovery().await {
            error!("failed to stop bluetooth discovery: {}", e);
            return Err(ProxyError::DbusCallFailed(format!(
                "failed to stop bluetooth discovery: {}",
                e
            )));
        }

        trace!("discovery stopped, retrieving managed objects");
        let managed_objects = match self.get_managed_objects().await {
            Ok(objects) => objects,
            Err(e) => {
                error!("failed to get managed objects: {}", e);
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to get managed objects: {}",
                    e
                )));
            }
        };
        trace!("managed objects retrieved, filtering devices...");
        let mut available_devices = Vec::new();
        for (_object_path, interfaces) in managed_objects.iter() {
            if let Some(device_props) = interfaces.get("org.bluez.Device1") {
                if let Some(device_props) = BluetoothDevice::from_properties(device_props) {
                    debug!("found device: {:?}", device_props);
                    available_devices.push(device_props);
                }
            }
        }
        info!("found {} available devices", available_devices.len());
        Ok(available_devices)
    }

    /// Attempts to connect to a Bluetooth device given its address.
    ///
    /// This asynchronous method performs the following steps:
    /// 1. Constructs a valid D-Bus object path for the device.
    /// 2. Attempts to create a device proxy using the generated object path.
    /// 3. Calls the `connect` method on the proxy to initiate the connection.
    ///
    /// # Arguments
    ///
    /// * `address` - The Bluetooth MAC address of the device as a string slice (e.g., `"XX:XX:XX:XX:XX:XX"`).
    ///
    /// # Returns
    ///
    /// * `Ok(())` if the connection is successful.
    /// * `Err` if any step fails, with context-specific error information.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The device path is invalid.
    /// - The proxy could not be created.
    /// - The connection attempt fails.
    ///
    /// # Example
    ///
    /// ```ignore
    /// // Assuming `my_struct` implements this method
    /// let my_struct = ...; // obtain or create your struct here
    /// my_struct.connect("AA:BB:CC:DD:EE:FF").await?;
    /// ```
    async fn connect(&self, address: &str) -> Result<(), ProxyError> {
        info!("request to connect to device: {}", address);
        let cn = &self.0.connection();

        // Create the device path string
        // Replace ":" with "_" to create a valid object path
        let device_path_str = format!(
            "{}_{}",
            DEVICE_OBJECT_PATH,
            address.replace(":", "_")
        );
        debug!("device path: {}", device_path_str);

        // Create the device path object from the string
        let _device_path = match ObjectPath::try_from(device_path_str.as_str()) {
            Ok(path) => path,
            Err(e) => {
                error!("invalid device path: {}", e);
                return Err(ProxyError::InvalidObjectPath(e.to_string()));
            }
        };

        // Create the device proxy using the device path string
        // If the device path string is not valid, use the _device_path
        match build_device_proxy(cn, device_path_str.as_str()).await {
            Ok(device_proxy) => match device_proxy.connect().await {
                Ok(_) => {
                    info!("connected to device: {}", address);
                    Ok(())
                }
                Err(e) => {
                    error!("failed to connect to device: {}", e);
                    Err(ProxyError::DbusCallFailed(format!(
                        "failed to connect to device: {}",
                        e
                    )))
                }
            },
            Err(e) => {
                error!("failed to create device proxy: {}", e);
                return Err(e.into());
            }
        }
    }

    /// Disconnects from a Bluetooth device given its address.
    ///
    /// This asynchronous method constructs a D-Bus object path from the device address,
    /// creates a proxy for the device, and calls the `disconnect` method to terminate the connection.
    ///
    /// # Arguments
    ///
    /// * `address` - The Bluetooth MAC address of the device as a string slice (e.g., `"XX:XX:XX:XX:XX:XX"`).
    ///
    /// # Returns
    ///
    /// * `Ok(())` if the device is successfully disconnected.
    /// * `Err` if the device path is invalid, the proxy cannot be built, or the disconnect call fails.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The device path string is invalid.
    /// - The device proxy cannot be created.
    /// - The D-Bus call to disconnect fails.
    ///
    /// # Example
    ///
    /// ```ignore
    /// my_struct.connect("AA:BB:CC:DD:EE:FF").await?;
    /// ```
    async fn disconnect(&self, address: &str) -> Result<(), ProxyError> {
        let cn = &self.0.connection();
        let device_path_str = format!(
            "{}_{}",
            DEVICE_OBJECT_PATH,
            address.replace(":", "_")
        );
        let _device_path = match ObjectPath::try_from(device_path_str.as_str()) {
            Ok(path) => path,
            Err(e) => {
                error!("invalid device path: {}", e);
                return Err(ProxyError::InvalidObjectPath(e.to_string()));
            }
        };

        //note: if device path str is not valid then use _device_path
        match build_device_proxy(cn, device_path_str.as_str()).await {
            Ok(device_proxy) => match device_proxy.disconnect().await {
                Ok(_) => Ok(()),
                Err(e) => {
                    error!("failed to disconnect from device: {}", e);
                    Err(ProxyError::DbusCallFailed(format!(
                        "failed to disconnect from device: {}",
                        e
                    )))
                }
            },
            Err(e) => {
                error!("failed to build device proxy: {}", e);
                return Err(e.into());
            }
        }
    }

    /// Retrieves a list of currently connected Bluetooth devices.
    ///
    /// This asynchronous method fetches all managed objects from BlueZ,
    /// filters for devices that are currently connected, and returns their properties.
    ///
    /// # Returns
    ///
    /// * `Ok(Vec<BluetoothDevice>)` - A vector of properties for each connected Bluetooth device.
    /// * `Err` - If managed objects cannot be retrieved or parsed.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The retrieval of managed objects fails.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let connected_devices = my_struct.get_connected_devices().await?;
    /// for device in connected_devices {
    ///     println!("{:?}", device);
    /// }
    /// ```
    async fn get_connected_devices(&self) -> Result<Vec<BluetoothDevice>, ProxyError> {
        info!("request to get connected devices");
        // Retrieve all managed objects from BlueZ
        // This will include all devices, adapters, etc.
        let managed_objects = match self.get_managed_objects().await {
            Ok(objects) => objects,
            Err(e) => {
                error!("failed to get managed objects: {}", e);
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to get managed objects: {}",
                    e
                )));
            }
        };
        let mut connected_devices = Vec::new();
        for (_object_path, interfaces) in managed_objects.iter() {
            if let Some(device_props) = interfaces.get("org.bluez.Device1") {
                if let Some(device) = BluetoothDevice::from_properties(device_props) {
                    // Check if the device is connected
                    // The connected property is a boolean indicating the connection status
                    if device.connected {
                        connected_devices.push(device);
                    }
                }
            }
        }
        info!("found {} connected devices", connected_devices.len());
        // Return the list of connected devices
        Ok(connected_devices)
    }

    async fn stream_bluetooth_enabled_status(&self) -> Result<PropertyStream<bool>, ProxyError> {
        let cn = &self.0.connection();
        let proxy = Adapter1Proxy::new(&cn).await.unwrap();
        let stream = proxy.receive_powered_changed().await;
        Ok(stream)
    }
    async fn stream_bluetooth_events(&self) -> Result<(InterfacesAddedStream, InterfacesRemovedStream), ProxyError> {
        let cn = &self.0.connection();
        let bluez = BluezProxy::new(&cn).await.unwrap();
        let added = match bluez.receive_interfaces_added().await {
            Ok(stream) => stream,
            Err(e) => {
                error!("failed to stream interfaces added: {}", e);
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to stream interfaces added: {}",
                    e
                )));
            }
        };
        let removed = match bluez.receive_interfaces_removed().await {
            Ok(stream) => stream,
            Err(e) => {
                error!("failed to stream interfaces removed: {}", e);
                return Err(ProxyError::DbusCallFailed(format!(
                    "failed to stream interfaces removed: {}",
                    e
                )));
            }
        };
        Ok((added, removed))
    }
}
